// Generated by CoffeeScript 1.7.1
(function() {
  var FrameRenderer, Puppet, Puppeteer;

  if (!('animationFrame' in this)) {
    this.animationFrame = (function() {
      return this.requestAnimationFrame || this.webkitRequestAnimationFrame || this.mozRequestAnimationFrame || this.oRequestAnimationFrame || this.msRequestAnimationFrame || function(callback) {
        this.setTimeout(callback, 1000 / 60);
      };
    })();
  }

  FrameRenderer = (function() {
    function FrameRenderer(element, fps, frames, onRender) {
      this.element = element;
      this.fps = fps != null ? fps : 60;
      this.frames = frames;
      this.onRender = onRender;
      console.log('new FrameRenderer ' + this.fps);
      this.msfps = parseInt(1000 / this.fps);
      this.render.bind(this.element);
    }

    FrameRenderer.prototype.render = function(time, element) {
      var context, currentFrame, elapsed, interval, nextFrame, now, reset, shouldRender, start;
      context = this;
      now = Date.now();
      start = this.element.data('animationStartTime');
      if (!start) {
        start = now;
        this.element.data('animationStartTime', time);
      }
      elapsed = time - start;
      interval = this.element.data('interval');
      shouldRender = false;
      reset = false;
      currentFrame = this.element.data('currentFrame');
      if (currentFrame === this.element.data('options').stop_after) {
        return false;
      }
      if (interval === "paused") {
        shouldRender = false;
      } else {
        if (elapsed > this.msfps) {
          shouldRender = true;
          reset = true;
        } else {
          shouldRender = false;
          this.element.data('_requestId', animationFrame(function(e, element) {
            return context.render(e, element);
          }));
          return;
        }
      }
      if (shouldRender) {
        nextFrame = (currentFrame % this.frames) + 1;
        this.element.data('prevFrame', currentFrame);
        this.element.data('currentFrame', nextFrame);
        if (reset) {
          this.element.data('animationStartTime', time);
        }
        this.element.data('_requestId', animationFrame(function(e, element) {
          return context.render(e, element);
        }));
        this.onRender.apply(this, [this.element, currentFrame, nextFrame]);
      }
      return this;
    };

    return FrameRenderer;

  })();

  Puppet = (function() {
    Puppet.prototype.renderer = null;

    Puppet.prototype._data = {};

    function Puppet(element, name) {
      this.element = element;
      this.name = name != null ? name : null;
    }

    Puppet.prototype.data = function(key, value) {
      if (key == null) {
        key = null;
      }
      if (value == null) {
        value = null;
      }
      if (key === null && value === null) {
        return this._data;
      }
      if (typeof key === 'object') {
        return this._data = key;
      } else if (typeof key === 'string') {
        if (value === null) {
          return this._data[key];
        } else {
          return this._data[key] = value;
        }
      }
    };

    Puppet.prototype.destroy = function() {
      console.log('before dtty', this);
      return Puppeteer.destroy(this.name);
    };

    Puppet.prototype.pause = function() {
      return this.data('interval', 'paused');
    };

    Puppet.prototype.play = function() {
      if (!this.data('_requestId')) {
        this.data('interval', 'playing');
        this.animate();
      }
    };

    Puppet.prototype.animate = function() {
      var context, requestId;
      if (this.renderer) {
        context = this;
        requestId = animationFrame(function(e, element) {
          return context.renderer.render(e, element);
        });
        return this.data('_requestId', requestId);
      } else {
        return console.debug("!renderObject", this.element, this.data());
      }
    };

    return Puppet;

  })();

  Puppeteer = (function() {
    function Puppeteer() {}

    Puppeteer.instances = {};

    Puppeteer.create = function(element, options) {
      var id, instance;
      this.element = element;
      if (!this.element.getAttribute("id")) {
        this.element.setAttribute("id", this.rid());
      }
      id = this.element.id;
      element = this.bid(id);
      this.element.className += " " + options.mask.replace("%d", options.initFrame);
      instance = (function(element, sid) {
        instance = new Puppet(element, sid);
        instance.data({
          "options": options,
          "prevFrame": 0,
          "currentFrame": 0,
          "animationStartTime": void 0,
          "interval": (options.autostart ? "playing" : "paused")
        });
        instance.renderer = new FrameRenderer(instance, options["fps"], options.frames, function() {
          if (this.element.data('options').type === "css") {
            Puppeteer.animateClass(this.element);
          }
          if (this.element.data('options').type === "sprite") {
            return Puppeteer.animateSprite(this.element);
          }
        });
        Puppeteer.instances[id] = instance;
        return instance;
      })(element, id);
      if (options.autostart) {
        instance.animate();
      }
      return instance;
    };

    Puppeteer.bid = function(id) {
      return document.getElementById(id);
    };

    Puppeteer.rid = function() {
      var e, i, seed;
      seed = [];
      e = Math.random();
      i = 65;
      while (i < 91) {
        seed.push(String.fromCharCode(i));
        i++;
      }
      return seed.sort(function() {
        return Math.random() > e;
      }).slice(0, 12).join("");
    };

    Puppeteer.get = function(instanceId) {
      return this.instances[instanceId];
    };

    Puppeteer.destroy = function(id) {
      var p;
      console.log('destroy->' + id);
      p = Puppeteer.get(id);
      if ("cancelAnimationFrame" in window) {
        cancelAnimationFrame(p.data("_requestId"));
      } else {
        clearTimeout(p.data("_requestId"));
      }
    };

    Puppeteer.animateSprite = function() {};

    Puppeteer.animateClass = function(puppet) {
      var className, currentClass, el, mask, newClass, regex;
      el = puppet.element;
      mask = puppet.data("options").mask;
      className = el.className;
      currentClass = mask.replace("%d", puppet.data('prevFrame'));
      newClass = mask.replace("%d", puppet.data('currentFrame'));
      regex = new RegExp(currentClass, "gim");
      el.setAttribute('class', className.replace(regex, newClass));
    };

    return Puppeteer;

  })();

  this.VideoPuppeteer = Puppeteer;

  !(function(scope) {
    if (!(scope.console && console.log)) {
      (function() {
        var console, length, methods, noop;
        noop = function() {};
        methods = ["assert", "clear", "count", "debug", "dir", "dirxml", "error", "exception", "group", "groupCollapsed", "groupEnd", "info", "log", "markTimeline", "profile", "profileEnd", "markTimeline", "table", "time", "timeEnd", "timeStamp", "trace", "warn"];
        length = methods.length;
        console = scope.console = {};
        while (length--) {
          console[methods[length]] = noop;
        }
      })();
    } else {
      scope.log = function() {
        scope.console.log(Array.prototype.slice.call(arguments));
      };
      scope.debug = function() {
        scope.console.debug(Array.prototype.slice.call(arguments));
      };
    }
    "jQuery" in scope && (function() {
      $.fn.extend({
        VideoPuppeteer: function(options) {
          var me;
          me = $(this);
          options = $.extend(options || {}, {
            type: "sprite",
            do_once: false,
            autostart: false,
            width: null,
            height: null,
            fps: 24,
            frames: 2,
            stop_after: null
          });
          return new Puppeteer(me, options);
        }
      });
    })(scope.jQuery);
  }, this);

}).call(this);

//# sourceMappingURL=animate.map
